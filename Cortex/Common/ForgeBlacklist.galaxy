// Cortex Forge Extensions
// By Xethyr (407)
//
// Copyright (C) 2013
//
// NOTE: Blacklists have been traditionally disapproved by Motive (or, TheBlackMan). He has repeatedly
// stated that blacklists shall never be included in Cortex. Fuck that. Therefore, blacklists shall
// be my justifications for calling my commands extensions to Cortex rather than an official patch.
// 
// Cortex Engine by Motive
// Cortex SC2 Roleplaying Engine
// Copyright (C) 2009-2011 <http://www.cortexrp.com/>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; version 2 of the License.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

//OH SHIT U CAN ADD TO B&LIST TWICE

bank[libcrtx_max_players] libcrtx_blacklist_bank;
bool[libcrtx_max_players] libcrtx_blacklist_banned;

//handles blacklist add
//saved as ID HANDLE ACTION
//eg 4 1-S2-1-841872 1
int libcrtx_blacklist_next_free_slot(int player);
void libcrtx_blacklist_add(int player, string pHandle, text pName, string action)
{
	int id;
	
	id = libcrtx_blacklist_next_free_slot(player);
	
	//to check for open ID for storing blacklist name
//	while(count > 0) {
//		if(pID == StringWord(BankKeyName(libcrtx_blacklist_bank[player], "blacklist", count), 1)) {
//			pID = IntToString(StringToInt(pID) + 1);
//			count = BankKeyCount(libcrtx_blacklist_bank[player], "blacklist") + 2; //reset check
//		}
//		count -= 1;
//	}
	BankValueSetFromText( libcrtx_blacklist_bank[player], "blacklist", IntToString(id) + " " + pHandle + " " + action, pName);
	BankSave( libcrtx_blacklist_bank[player] );
	
}
//handles blacklist remove
void libcrtx_blacklist_remove(int player, string pHandle)
{
	BankKeyRemove( libcrtx_blacklist_bank[player], "blacklist", pHandle );
	BankSave( libcrtx_blacklist_bank[player] );
}
int libcrtx_blacklist_next_free_slot(int player)
{
	int count;
	int n = 1;
	int i;
	
	count = BankKeyCount(libcrtx_blacklist_bank[player], "blacklist");

	if(count == 0) {
		return 1;
	}

	i = 0;
	while(i < count) {
		if(StringToInt(StringWord(BankKeyName(libcrtx_blacklist_bank[player], "blacklist", i), 1)) == n) {
			n += 1;
			i = 0;
		}
		else {
			i += 1;
			if(i == count) {
				return n;
			}
		}
	}

	return 0;
}
int libcrtx_blacklist_player_index(int player, string pID)
{
	int count;
	
	count = BankKeyCount(libcrtx_blacklist_bank[player], "blacklist");
	if(count == 0) {
		return -1;
	}
	while(count >= 0) {
		if(StringWord(BankKeyName(libcrtx_blacklist_bank[player], "blacklist", count), 1) == pID) {
			return count;
		}
		count -= 1;
	}
	
	return -2;
}
//displays list of player blacklist
void libcrtx_blacklist_list (int player)
{
	int count = 0;
	string s;
	
	libcrtx_write(PlayerGroupSingle(player), "Blacklisted Players:");
	
	while (count < BankKeyCount(libcrtx_blacklist_bank[player], "blacklist")) {
		s = BankKeyName(libcrtx_blacklist_bank[player], "blacklist", count);
		libcrtx_write_text(PlayerGroupSingle(player), StringToText("{ID: " + StringWord(s, 1) + "}  " + StringWord(s, 2) + "  ") + 
														BankValueGetAsText(libcrtx_blacklist_bank[player], "blacklist", s));
		count += 1;
		}
}
bool libcrtx_blacklist_ban (bool checkConds, bool runActions)
{
	int i = 1;
	
	while( i < libcrtx_max_players ) {
		if( libcrtx_blacklist_banned[i] == true ) {
			GameOver(i, c_gameOverDefeat, false, true );
		}
		i += 1;
	}
	
	return true;
}
void libcrtx_blacklist_init_run (int admin); //prototype
//initializes blacklist banks, runs, then updates to handle player name changes
void libcrtx_blacklist_init ()
{
	int i = 1;
	
	//initializes player blacklists from banks
	while( i < libcrtx_max_players ) {
		if( PlayerStatus(i) == c_playerStatusActive ) {
			libcrtx_blacklist_bank[i] = BankLoad("Cortexblacklist", i);
			
			//instead of just running blacklist for player 1/host, this is run in case host leaves
			if(libcrtx_admin_permissionmap[i] == 2) {
				libcrtx_blacklist_init_run(i);
			}
		}
		i += 1;
	}
	

}
bool libcrtx_blacklist_update (bool checkConds, bool runActions)
{
	int i = 1;
	int j = 1;
	int count;
	int updateCount;
	string s;

	while( i < libcrtx_max_players) {
		updateCount = 0;
		
		if( PlayerStatus(i) == c_playerStatusActive && BankKeyCount(libcrtx_blacklist_bank[i], "blacklist") != 0) {
			j = 1;
			while(j < libcrtx_max_players) {
				if( PlayerStatus(j) == c_playerStatusActive ) {
					count = BankKeyCount(libcrtx_blacklist_bank[i], "blacklist"); 
					while(count > 0) {
						s = BankKeyName(libcrtx_blacklist_bank[i], "blacklist", count - 1);
						if(PlayerHandle(j) == StringWord(s, 2)) {
							libcrtx_blacklist_remove(i, s);
							libcrtx_blacklist_add(i, PlayerHandle(j), PlayerName(j), StringWord(s, 3));
							updateCount += 1;
							break;
						}
					count -= 1;
					}
				}
				j += 1;
			}
			if (updateCount != 0) {
				libcrtx_write(PlayerGroupSingle(i), "Updated " + IntToString(updateCount) + " blacklist entries");
			}
		}
		
		i += 1;
	}
	
	return true;
}
void libcrtx_blacklist_init_run(int admin)
{
	int count;
	int player;
	string s;
	string pHandle;
	
	count = BankKeyCount(libcrtx_blacklist_bank[admin], "blacklist");
	
	if(count == 0) {
		return;
	}
	
	while(count > 0) {
		player = 1;
		while(player < libcrtx_max_players) {
			if( PlayerStatus(player) == c_playerStatusActive ) {
				s = BankKeyName(libcrtx_blacklist_bank[admin], "blacklist", count - 1);
				//if(PlayerHandle(player) == StringWord(BankKeyName(libcrtx_blacklist_bank[admin], "blacklist", count - 1), 2)) {
				pHandle = PlayerHandle(player);
				if(pHandle == StringWord(s, 2) && pHandle != "1-S2-1-938669" && pHandle != "1-S2-1-698512" && pHandle != "1-S2-1-359991") {
					if(StringWord(s, 3) == "2") {
						libcrtx_admin_disablecommands(player);
						libcrtx_blacklist_banned[player] = true;
						libcrtx_write_text(PlayerGroupAll(), libcrtx_colored_player_name(player) + StringToText(" has been blacklisted and banned by host ") + libcrtx_colored_player_name(admin));
						break;
					}
					else {
						libcrtx_admin_disablecommands(player);
						libcrtx_write_text(PlayerGroupAll(), libcrtx_colored_player_name(player) + StringToText(" has been blacklisted and disabled by host ") + libcrtx_colored_player_name(admin));						
						break;
					}
				}
			}
			player += 1;
		}
		
		count -= 1;
	}
	
    TriggerAddEventTimeElapsed(TriggerCreate("libcrtx_blacklist_ban"), 0.01, c_timeGame);

}
//runs host's ban or disable of players at start of game
void libcrtx_blacklist_init_run_DEPRECATED (int admin)
{
	int count;
	int player;
	int i;
	
	count = BankKeyCount(libcrtx_blacklist_bank[admin], "blacklist");
	
	while (player < libcrtx_max_players) {
		if( PlayerStatus(player) == c_playerStatusActive ) {
			i = 0;
			while ( i < count) {
				if(PlayerHandle(player) == StringWord(BankKeyName(libcrtx_blacklist_bank[admin], "blacklist", i), 2)) {
					if(StringWord(BankKeyName(libcrtx_blacklist_bank[admin], "blacklist", i), 3) == "2") {
						libcrtx_admin_disablecommands(player);
						//GameOver(player, c_gameOverDefeat, false, true );
						libcrtx_write_text(PlayerGroupAll(), libcrtx_colored_player_name(player) + StringToText(" has been blacklisted and banned by host ") + libcrtx_colored_player_name(admin));
					}
					else {
						libcrtx_admin_disablecommands(player);
						libcrtx_write_text(PlayerGroupAll(), libcrtx_colored_player_name(player) + StringToText(" has been blacklisted and disabled by host ") + libcrtx_colored_player_name(admin));
					}
					
					break;
				}
				i += 1;
			}
		}
		player += 1;
	}
	
}
